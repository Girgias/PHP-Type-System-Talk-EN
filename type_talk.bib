
@misc{popov_type_nodate,
	title = {Type variance in {PHP}},
	url = {https://www.npopov.com/2021/11/08/Type-variance-in-PHP.html},
	language = {English},
	urldate = {2022-05-30},
	author = {Popov, Nikita},
	file = {Type variance in PHP:/home/girgias/Zotero/storage/RKFBIBHT/Type-variance-in-PHP.html:text/html},
}

@misc{noauthor_forme_2022,
	title = {Forme normale disjonctive},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://fr.wikipedia.org/w/index.php?title=Forme_normale_disjonctive&oldid=193799539},
	abstract = {En logique booléenne ou en calcul des propositions, une forme normale disjonctive ou FND (en anglais, disjunctive normal form  ou DNF)  est une normalisation d'une expression logique qui est une disjonction de clauses conjonctives. Elle est utilisée dans la démonstration automatique de théorèmes. Une expression logique est en FND si et seulement si elle est une disjonction d'une ou plusieurs conjonctions d'un ou plusieurs littéraux. Tout comme dans une forme normale conjonctive (FNC), les seuls opérateurs dans une FND sont le et logique, le ou logique et la négation.},
	language = {fr},
	urldate = {2022-10-10},
	journal = {Wikipédia},
	month = may,
	year = {2022},
	note = {Page Version ID: 193799539},
}

@article{liskov_behavioral_1994,
	title = {A behavioral notion of subtyping},
	volume = {16},
	issn = {0164-0925},
	url = {https://doi.org/10.1145/197320.197383},
	doi = {10.1145/197320.197383},
	abstract = {The use of hierarchy is an important component of object-oriented design. Hierarchy allows the use of type families, in which higher level supertypes capture the behavior that all of their subtypes have in common. For this methodology to be effective, it is necessary to have a clear understanding of how subtypes and supertypes are related. This paper takes the position that the relationship should ensure that any property proved about supertype objects also holds for its subtype objects. It presents two ways of defining the subtype relation, each of which meets this criterion, and each of which is easy for programmers to use. The subtype relation is based on the specifications of the sub- and supertypes; the paper presents a way of specifying types that makes it convenient to define the subtype relation. The paper also discusses the ramifications of this notion of subtyping on the design of type families.},
	number = {6},
	urldate = {2022-10-10},
	journal = {ACM Transactions on Programming Languages and Systems},
	author = {Liskov, Barbara H. and Wing, Jeannette M.},
	month = nov,
	year = {1994},
	keywords = {formal specifications, Larch, subtyping},
	pages = {1811--1841},
	file = {Full Text PDF:/home/girgias/Zotero/storage/29DPWR2F/Liskov and Wing - 1994 - A behavioral notion of subtyping.pdf:application/pdf},
}

@misc{seemann_liskov_2021,
	type = {Blog},
	title = {The {Liskov} {Substitution} {Principle} as a profunctor},
	url = {https://blog.ploeh.dk/2021/12/06/the-liskov-substitution-principle-as-a-profunctor/},
	language = {English},
	urldate = {2022-10-10},
	journal = {ploeh blog danish software design},
	author = {Seemann, Mark},
	month = dec,
	year = {2021},
	file = {The Liskov Substitution Principle as a profunctor:/home/girgias/Zotero/storage/ETFQ32GF/the-liskov-substitution-principle-as-a-profunctor.html:text/html},
}

@misc{banyard_saner_2020,
	title = {Saner numeric strings},
	url = {https://wiki.php.net/rfc/saner-numeric-strings},
	language = {English},
	urldate = {2022-10-10},
	author = {Banyard, George Peter},
	month = jun,
	year = {2020},
}

@misc{banyard_disjunctive_2022,
	title = {Disjunctive {Normal} {Form} {Types}},
	url = {https://wiki.php.net/rfc/dnf_types},
	language = {English},
	urldate = {2022-10-10},
	author = {Banyard, George Peter},
	month = apr,
	year = {2022},
}

@misc{banyard_add_2022,
	title = {Add true type},
	url = {https://wiki.php.net/rfc/true-type},
	language = {English},
	urldate = {2022-10-10},
	author = {Banyard, George Peter},
	month = apr,
	year = {2022},
}

@misc{banyard_allow_2022,
	title = {Allow null and false as stand-alone types},
	url = {https://wiki.php.net/rfc/null-false-standalone-types},
	language = {English},
	urldate = {2022-10-10},
	author = {Banyard, George Peter},
	month = feb,
	year = {2022},
}

@misc{banyard_pure_2021,
	title = {Pure intersection types},
	url = {https://wiki.php.net/rfc/pure-intersection-types},
	language = {English},
	urldate = {2022-10-10},
	author = {Banyard, George Peter},
	month = mar,
	year = {2021},
}

@misc{noauthor_type_2022,
	title = {Type system},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Type_system&oldid=1114430701},
	abstract = {In computer programming, a type system is a logical system comprising a set of rules that assigns a property called a type to every "term" (a word, phrase, or other set of symbols). Usually the terms are various constructs of a computer program, such as variables, expressions, functions, or modules. A type system dictates the operations that can be performed on a term. For variables, the type system determines the allowed values of that term. Type systems formalize and enforce the otherwise implicit categories the programmer uses for algebraic data types, data structures, or other components (e.g. "string", "array of float", "function returning boolean").
Type systems are often specified as part of programming languages and built into interpreters and compilers, although the type system of a language can be extended by optional tools that perform added checks using the language's original type syntax and grammar. The main purpose of a type system in a programming language is to reduce possibilities for bugs in computer programs due to type errors. The given type system in question determines what constitutes a type error, but in general, the aim is to prevent operations expecting a certain kind of value from being used with values for which that operation does not make sense (validity errors). Type systems allow defining interfaces between different parts of a computer program, and then checking that the parts have been connected in a consistent way. This checking can happen statically (at compile time), dynamically (at run time), or as a combination of both. Type systems have other purposes as well, such as expressing business rules, enabling certain compiler optimizations, allowing for multiple dispatch, and providing a form of documentation.},
	language = {en},
	urldate = {2022-10-10},
	journal = {Wikipedia},
	month = oct,
	year = {2022},
	note = {Page Version ID: 1114430701},
	file = {Snapshot:/home/girgias/Zotero/storage/HRMVIDUD/Type_system.html:text/html},
}

@misc{noauthor_disjunctive_2022,
	title = {Disjunctive normal form},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Disjunctive_normal_form&oldid=1097076215},
	abstract = {In boolean logic, a disjunctive normal form (DNF) is a canonical normal form of a logical formula consisting of a disjunction of conjunctions; it can also be described as an OR of ANDs, a sum of products, or (in philosophical logic) a cluster concept.  As a normal form, it is useful in automated theorem proving.},
	language = {en},
	urldate = {2022-10-24},
	journal = {Wikipedia},
	month = jul,
	year = {2022},
	note = {Page Version ID: 1097076215},
	file = {Snapshot:/home/girgias/Zotero/storage/NTG7DTG3/Disjunctive_normal_form.html:text/html},
}

@misc{banyard_path_2022,
	title = {Path to {Saner} {Increment}/{Decrement} operators},
	url = {https://wiki.php.net/rfc/saner-inc-dec-operators},
	urldate = {2023-02-15},
	author = {Banyard, George Peter},
	month = nov,
	year = {2022},
	file = {PHP\: rfc\:saner-inc-dec-operators:/home/girgias/Zotero/storage/QWH4ZDNT/saner-inc-dec-operators.html:text/html},
}

@misc{banyard_saner_2023,
	title = {Saner array\_(sum{\textbar}product)()},
	url = {https://wiki.php.net/rfc/saner-array-sum-product},
	urldate = {2023-02-15},
	author = {Banyard, George Peter},
	month = jan,
	year = {2023},
	file = {PHP\: rfc\:saner-array-sum-product:/home/girgias/Zotero/storage/Q3KHXJQQ/saner-array-sum-product.html:text/html},
}

@misc{noauthor_subtyping_2022,
	title = {Subtyping},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Subtyping&oldid=1127276117},
	abstract = {In programming language theory, subtyping (also subtype polymorphism or inclusion polymorphism) is a form of type polymorphism in which a subtype is a datatype that is related to another datatype (the supertype) by some notion of substitutability, meaning that program elements, typically subroutines or functions, written to operate on elements of the supertype can also operate on elements of the subtype. If S is a subtype of T, the subtyping relation (written as S {\textless}: T,  S ⊑ T, or  S ≤: T ) means that any term of type S can safely be used in any context where a term of type T is expected.},
	language = {en},
	urldate = {2023-02-15},
	journal = {Wikipedia},
	month = dec,
	year = {2022},
	note = {Page Version ID: 1127276117},
	file = {Snapshot:/home/girgias/Zotero/storage/K2SK9E65/Subtyping.html:text/html},
}